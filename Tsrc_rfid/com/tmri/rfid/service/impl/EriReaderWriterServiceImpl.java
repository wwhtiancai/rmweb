package com.tmri.rfid.service.impl;

import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;

import com.sansec.hsm.saf.SAFAPI;
import com.sansec.hsm.saf.SAFCrypto;
import com.sansec.hsm.saf.SAFResult;
import com.sansec.impl.device.util.Bytes;
import com.tmri.rfid.bean.EriReaderWriter;
import com.tmri.rfid.bean.EriReaderWriterActivation;
import com.tmri.rfid.common.EriReaderWriterActivateStatus;
import com.tmri.rfid.mapper.EriReaderWriterMapper;
import com.tmri.rfid.mapper.EriReaderWriterStatus;
import com.tmri.rfid.service.*;
import com.tmri.rfid.util.EriUtil;
import com.tmri.rfid.util.MapUtilities;
import com.tmri.rfid.util.SAM_BINDRECV_FRAME;

import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import javax.annotation.Resource;

/**
 * Created by st on 2015/12/3.
 */
@Service
public class EriReaderWriterServiceImpl extends BaseServiceImpl implements EriReaderWriterService {

    private final static Logger LOG = LoggerFactory.getLogger(EriReaderWriterServiceImpl.class);

    @Autowired
    private EriReaderWriterMapper eriReaderWriterMapper;

    @Resource
    private EriReaderWriterActivationService eriReaderWriterActivationService;

    public EriReaderWriter fetchByXh(String xh) {
        return eriReaderWriterMapper.queryById(xh);
    }

    @Override
    public boolean update(EriReaderWriter eriReaderWriter) throws Exception {
        return eriReaderWriterMapper.update(eriReaderWriter) > 0;
    }

    public boolean create(EriReaderWriter readerWriter) {
        return eriReaderWriterMapper.create(readerWriter) > 0;
    }

	@Override
	public EriReaderWriterActivation activate(String hexBuffer, String caPubkeyIndex) throws Exception {
        EriReaderWriterActivation erwa = new EriReaderWriterActivation();
        // TODO Auto-generated method stub
        byte[] buffer = Bytes.hex2bytes(hexBuffer);
        int len = buffer.length;
        SAFAPI safapi;
        SAFResult result = null;

        int bindReqLen = len - 7;//6字节头+1字节校验位(还有1字节校验位)
        //**************************模拟后台服务器程序**************************
        //解析数字信封
        byte[] bindReq = new byte[2048];
        System.arraycopy(buffer, 0, bindReq, 0, bindReqLen);

        byte[] deviceSerialNum = new byte[8];
        System.arraycopy(bindReq, 3, deviceSerialNum, 0, 8);
        String deviceSerialNo = EriUtil.bytesToHex(deviceSerialNum);
        LOG.info("激活读写器，传入设备序列号：" + deviceSerialNo);

        //解密授权申请
        byte[] encyptDataC2 = new byte[320];//安全模块序列号+读写设备序列号（待绑定的+原先绑定的（如果有的话））+密管中心保留+转发数据+签名
        byte[] encyptDataC1 = new byte[64];
        byte[] encyptDataC3 = new byte[32];
        System.arraycopy(bindReq, 24, encyptDataC2, 0, 320);
        System.arraycopy(bindReq, 344, encyptDataC1, 0, 64);
        System.arraycopy(bindReq, 408, encyptDataC3, 0, 32);

        byte[] encyptData = new byte[416];
        System.arraycopy(encyptDataC1, 0, encyptData, 0, 64);
        System.arraycopy(encyptDataC3, 0, encyptData, 64, 32);
        System.arraycopy(encyptDataC2, 0, encyptData, 96, 320);

        byte[] decryptData = new byte[320];
        safapi = SAFCrypto.getInstance();
        safapi.SAF_SetMessHeaderLen(0);

        int currentCAPubKeyIndex = Integer.parseInt(caPubkeyIndex);

        result = safapi.SAF_SM2PriKeyDecrypt(currentCAPubKeyIndex, 416, encyptData);
        if (result.getResultCode() == 0 && result.getData() != null) {
            decryptData = result.getData();
        } else {
            throw new RuntimeException("解密错误");
        }

        //解密后的序列号
        byte[] samSerialNum = new byte[8];
        byte[] newDeviceNum = new byte[8];
        byte[] oldDeviceNum = new byte[8];
        byte[] transmitData = new byte[224];
        byte[] sign = new byte[64];
        System.arraycopy(decryptData, 0, samSerialNum, 0, 8);
        String samSerialNo = EriUtil.bytesToHex(samSerialNum);
        System.arraycopy(decryptData, 8, newDeviceNum, 0, 8);
        String newDeviceNo = EriUtil.bytesToHex(newDeviceNum);
        System.arraycopy(decryptData, 16, oldDeviceNum, 0, 8);
        String oldDeviceNo = EriUtil.bytesToHex(oldDeviceNum);

        if (StringUtils.isEmpty(deviceSerialNo) || StringUtils.isEmpty(newDeviceNo) ||
                !deviceSerialNo.equals(newDeviceNo)) {
            LOG.error("传入设备序列号与解密后的设备序列号不一致");
            throw new RuntimeException("传入设备序列号与解密后的设备序列号不一致");
        }

        EriReaderWriterActivation activation =
                eriReaderWriterActivationService.fetchInProgress(newDeviceNo);

        if (activation != null) {
            throw new RuntimeException("当前设备正在进行激活，如需要重新激活，请将之前的激活更新为失败");
        }

        System.arraycopy(decryptData, 32, transmitData, 0, 224);
        System.arraycopy(decryptData, 256, sign, 0, 64);

        LOG.info(String.format("激活读写器，安全模块序列号：%s,原读写器序列号：%s,新读写器序列号：%s", samSerialNo, oldDeviceNo, newDeviceNo));

        ////验证安全模块数字证书是否由CA签发
        int lenhigh = bindReq[442];
        int lenlow = bindReq[443];
        int tmp = lenhigh << 8;
        int samCertLen = tmp + lenlow + 4;
        byte[] samCert = new byte[2048];
        System.arraycopy(bindReq, 440, samCert, 0, samCertLen);
        byte[] samPubKey = new byte[64];
        //GetPubKeyFromCert(samCert, samPubKey);//解析公钥的方法
        String samCertStr = EriUtil.bytesToHex(samCert);
        String samPubKeyStr = null;
        samPubKeyStr = EriUtil.getPubKeyFromCert(samCertStr);
        samPubKey = Bytes.hex2bytes(samPubKeyStr);

        byte[] signData = new byte[256];
        System.arraycopy(samSerialNum, 0, signData, 0, 8);
        System.arraycopy(newDeviceNum, 0, signData, 8, 8);
        System.arraycopy(oldDeviceNum, 0, signData, 16, 8);
        System.arraycopy(transmitData, 0, signData, 32, 224);

        //先做SM3
        byte[] jiamijiDigest = new byte[32];
        byte[] ID = new byte[10];
        result = safapi.SAF_SM3_HASH(1, 0, ID, ID, 256, signData);
        if (result.getResultCode() == 0 && result.getData() != null) {
            jiamijiDigest = result.getData();
        } else {
            //exception "计算摘要错误"
            throw new Exception("计算摘要错误");
        }
        //摘要值先4字节反序后整体反序(安全芯片摘要结果不处理，保证加密机与安全芯片输入摘要顺序相反)
        byte[] jiamijiDigest4Reverse = new byte[32];
        byte[] jiamijiDigestFullReverse = new byte[32];
        for (int i = 0; i < 8; i++) {
            jiamijiDigest4Reverse[4 * i] = jiamijiDigest[4 * i + 3];
            jiamijiDigest4Reverse[4 * i + 1] = jiamijiDigest[4 * i + 2];
            jiamijiDigest4Reverse[4 * i + 2] = jiamijiDigest[4 * i + 1];
            jiamijiDigest4Reverse[4 * i + 3] = jiamijiDigest[4 * i];
        }
        for (int i = 0; i < 32; i++) {
            jiamijiDigestFullReverse[i] = jiamijiDigest4Reverse[31 - i];
        }
        //end SM3

        //执行验签
        byte[] jiamijiSignReverse = new byte[64];
        for (int i = 0; i < 32; i++) {
            jiamijiSignReverse[i] = sign[31 - i];
        }
        for (int i = 0; i < 32; i++) {
            jiamijiSignReverse[32 + i] = sign[63 - i];
        }

        result = safapi.SAF_SM2PubKeyVerify(0, samPubKey, jiamijiSignReverse, 32, jiamijiDigestFullReverse);
        if (result.getResultCode() != 0) {
            //exception "验签错误"
            throw new Exception("验签错误");
        }

        //签名授权许可信息
        SAM_BINDRECV_FRAME sam_bind_recv_Frame = new SAM_BINDRECV_FRAME();
        sam_bind_recv_Frame.header = (byte) 0xAA;
        sam_bind_recv_Frame.frameType = 0x31;
        sam_bind_recv_Frame.frameLength = 217;
        sam_bind_recv_Frame.operateId = 0x04;

        sam_bind_recv_Frame.transmitLength = 214;
        sam_bind_recv_Frame.transmitMethod = 0x01;
        sam_bind_recv_Frame.deviceSerial = new byte[8];
        System.arraycopy(newDeviceNum, 0, sam_bind_recv_Frame.deviceSerial, 0, 8);
        sam_bind_recv_Frame.reserve = new byte[13];
        sam_bind_recv_Frame.samdeviceSerial = new byte[16];
        sam_bind_recv_Frame.bindStream = new byte[8];
        sam_bind_recv_Frame.bindReserve = new byte[8];
        sam_bind_recv_Frame.sign = new byte[64];
        sam_bind_recv_Frame.C1 = new byte[64];
        sam_bind_recv_Frame.C3 = new byte[32];
        sam_bind_recv_Frame.checkSum = 0x00;

        byte[] bindStream = new byte[8];
        long bindstream = 1;

        bindStream[7] = (byte) (bindstream & 0xFF);
        bindStream[6] = (byte) (bindstream << 8 & 0xFF);
        bindStream[5] = (byte) (bindstream << 16 & 0xFF);
        bindStream[4] = (byte) (bindstream << 24 & 0xFF);
        bindStream[3] = (byte) (bindstream << 32 & 0xFF);
        bindStream[2] = (byte) (bindstream << 40 & 0xFF);
        bindStream[1] = (byte) (bindstream << 48 & 0xFF);
        bindStream[0] = (byte) (bindstream << 56 & 0xFF);


        byte[] bindSignData = new byte[32];
        System.arraycopy(samSerialNum, 0, bindSignData, 0, 8);
        System.arraycopy(newDeviceNum, 0, bindSignData, 8, 8);
        System.arraycopy(bindStream, 0, bindSignData, 16, 8);
        byte[] signResult = new byte[64];


        byte[] jiamijiDigestFullReverse2 = new byte[32];//上面已有同名对象？
        for (int i = 0; i < 32; i++) {
            jiamijiDigestFullReverse2[i] = bindSignData[31 - i];
        }
        //执行签名
        byte[] jiamijiSign = new byte[64];
        result = safapi.SAF_SM2PriKeySign(currentCAPubKeyIndex, 32, jiamijiDigestFullReverse2);//SM2签名
        if (result.getResultCode() == 0 && result.getData() != null) {
            jiamijiSign = result.getData();
        } else {
            //exception "签名错误"
            throw new RuntimeException("签名错误");
        }

        //签名反序(为了互通安全芯片，需要对相关参数做顺序转换)
        for (int i = 0; i < 32; i++) {
            signResult[i] = jiamijiSign[31 - i];
        }
        for (int i = 0; i < 32; i++) {
            signResult[32 + i] = jiamijiSign[63 - i];
        }

        //加密授权许可信息
        byte[] authPermitData = new byte[96];
        System.arraycopy(bindSignData, 0, authPermitData, 0, 32);
        System.arraycopy(signResult, 0, authPermitData, 32, 64);

        byte[] c1 = new byte[64];
        byte[] c3 = new byte[32];
        byte[] c2 = new byte[96];
        byte[] encryptData = new byte[96 + 96];//结果缓存
        result = safapi.SAF_SM2PubKeyEncrypt(0, samPubKey, 96, authPermitData);//0表示用外部SM2密钥加密
        if (result.getResultCode() == 0 && result.getData() != null) {
            encryptData = result.getData();
        } else {
            //exception "加密错误"
            throw new Exception("加密错误");
        }

        System.arraycopy(encryptData, 0, c1, 0, 64);
        System.arraycopy(encryptData, 64, c3, 0, 32);
        System.arraycopy(encryptData, 96, c2, 0, 96);


        //byte[] authPermitBuffer = structToBytes(sam_bind_recv_Frame, Marshal.SizeOf(sam_bind_recv_Frame));     
        byte[] authPermitBuffer = sam_bind_recv_Frame.toBytes();

        System.arraycopy(c2, 0, authPermitBuffer, 29, 96);
        System.arraycopy(c1, 0, authPermitBuffer, 125, 64);
        System.arraycopy(c3, 0, authPermitBuffer, 189, 32);
        //异或校验位
        byte xorCheck = 0;
        for (int i = 1; i < authPermitBuffer.length - 1; i++) {
            xorCheck = (byte) (xorCheck ^ authPermitBuffer[i]);
        }
        authPermitBuffer[authPermitBuffer.length - 1] = xorCheck;

        LOG.info(EriUtil.bytesToHex(authPermitBuffer));
        samSerialNo = EriUtil.parseSecurityModelXh(samSerialNo);
        erwa.setAqmkxh(samSerialNo);
        erwa.setDxqxh(newDeviceNo);
        erwa.setYdxqxh(oldDeviceNo);
        erwa.setCzrq(new Date());
        erwa.setYhxx(EriUtil.bytesToHex(transmitData));
        erwa.setActivateResponse(EriUtil.bytesToHex(authPermitBuffer));
        eriReaderWriterActivationService.create(erwa);
        EriReaderWriter readerWriter = eriReaderWriterMapper.queryById(newDeviceNo);
        if (readerWriter == null) {
            readerWriter = new EriReaderWriter();
            readerWriter.setXh(newDeviceNo);
            readerWriter.setAqmkxh(samSerialNo);
            readerWriter.setZt(EriReaderWriterStatus.NEW.getStatus());
            eriReaderWriterMapper.create(readerWriter);
        }
        return erwa;
    }

    @Override
    public void activateResult(String dxqxh, int zt, int sqzt, String sbyy) throws Exception {
        if (zt == EriReaderWriterActivateStatus.RESET.getStatus()) {
            //将所有激活中的读写器都置为激活失败
            eriReaderWriterActivationService.reset(dxqxh);
        } else {
            EriReaderWriterActivation activation = eriReaderWriterActivationService.fetchInProgress(dxqxh);
            activation.setZt(zt);
            activation.setSqzt(sqzt);
            activation.setSbyy(sbyy);
            activation.setWcrq(new Date());
            eriReaderWriterActivationService.update(activation);
            if (zt == EriReaderWriterActivateStatus.SUCCESS.getStatus()) {
                eriReaderWriterMapper.updateByCondition(MapUtilities.buildMap("cond_xh", activation.getDxqxh(),
                        "aqmkxh", activation.getAqmkxh(), "zt", EriReaderWriterStatus.ACTIVATED.getStatus(),
                        "jhrq", new Date(), "sqzt", sqzt, "yhxx", activation.getYhxx()));
            }
        }
    }

    @Override
    public List<EriReaderWriter> fetchByCondition(Map condition) throws Exception {
        return eriReaderWriterMapper.queryByCondition(condition);
    }

    public static void main(String args[]) throws Exception{
		
		String s = "0x03,0xCF,0x01,0x30,0x31,0x56,0x78,0x11,0x22,0x33,0x44,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC2,0xF8,0x73,0x02,0x2D,0x37,0xA3,0x5F,0x48,0x78,0x37,0xE2,0xF4,0xB2,0x1F,0xED,0x77,0x14,0xEA,0xD5,0x7E,0xDF,0x68,0x7A,0xE7,0x68,0x12,0x4F,0x56,0x88,0x79,0x68,0xEC,0x01,0x5D,0xA6,0x58,0xE8,0x6A,0x3E,0x70,0x19,0xBF,0x63,0x66,0xBA,0xF0,0xCA,0x4C,0xA9,0x4D,0x49,0x09,0x78,0x50,0x46,0x8E,0x2B,0x96,0x4B,0x68,0x4C,0xDB,0x7C,0x21,0x1C,0xA4,0xAF,0x06,0xC5,0xFA,0xF6,0x5B,0x52,0xC5,0xEA,0x14,0x04,0x30,0x28,0xD5,0xE8,0x84,0x1D,0xFF,0x7D,0x0C,0xF1,0x11,0x7A,0x7A,0x5C,0x88,0x6F,0xEF,0xA4,0xF8,0x61,0xB8,0x52,0x43,0xCB,0x8C,0x09,0x50,0xB4,0xCC,0x06,0xCD,0x47,0x45,0x01,0xB7,0xBC,0xBC,0x82,0xC9,0xEA,0xF1,0xE6,0x4C,0x4B,0x3B,0x92,0x0F,0xE9,0xC9,0xEC,0xDC,0x13,0xE6,0x33,0xA0,0x38,0x91,0x82,0xBB,0x94,0x70,0x40,0x2D,0xC5,0xD8,0x1F,0x55,0x5A,0xCC,0x67,0xAA,0xE1,0xB3,0x46,0x50,0x4B,0xFB,0x3D,0x6D,0x8D,0xA1,0xF8,0x8F,0xE6,0xE0,0x7B,0x18,0x81,0x13,0xD1,0x0A,0x9E,0x1E,0x26,0x9B,0xDA,0x1E,0x2A,0x79,0x38,0x1F,0x65,0x35,0xF7,0x45,0xB6,0x3F,0x12,0xE4,0xF3,0x1B,0x83,0x3F,0x88,0xB8,0xF6,0xDC,0xE5,0x31,0x1D,0x31,0x36,0x01,0x18,0x0F,0x0A,0x0D,0xB8,0x95,0x06,0x07,0xBB,0xD6,0x8B,0x64,0x55,0x19,0xDB,0x75,0xB6,0xEA,0x62,0x25,0x69,0x21,0x6A,0xE6,0xA7,0x00,0x61,0xDA,0x0A,0x0B,0x79,0x08,0xE1,0xB9,0x05,0xB3,0xC4,0x3C,0x94,0x59,0x9A,0x07,0x50,0xAA,0x57,0xCE,0x28,0x73,0x3B,0x09,0x0D,0xAC,0x37,0x79,0x93,0x15,0xC2,0x5A,0xF2,0x86,0x14,0x13,0x63,0x00,0x80,0x3D,0x2D,0xFB,0xC7,0xCF,0x31,0xED,0x99,0xAC,0x67,0xE5,0xB5,0x6D,0xDA,0xD6,0x3C,0xFA,0xAD,0x44,0x85,0x1E,0x1F,0x61,0x5A,0xED,0x46,0x18,0xDF,0xCA,0x35,0xC6,0xB9,0xD7,0x50,0x1C,0xD7,0x61,0x8D,0x89,0xF9,0x17,0xAA,0xB2,0x80,0x3B,0x43,0xEB,0x08,0x10,0x9A,0x01,0x3E,0xE8,0x93,0x82,0xD1,0x8C,0x66,0x53,0xBE,0x7A,0x3F,0xA2,0x23,0x47,0xF8,0xB2,0x9A,0x37,0xDF,0x8A,0x75,0x03,0x6D,0x06,0xB4,0x16,0x52,0x32,0xBF,0x55,0x1D,0x84,0x73,0xB6,0x14,0x38,0x21,0x7F,0xE0,0x4A,0x35,0x5D,0x64,0xEA,0xA1,0x26,0x8E,0xCB,0xE3,0x9B,0x5C,0xE9,0x13,0x5D,0x2E,0x83,0xDB,0x5C,0xA3,0xFB,0xB2,0x93,0x6A,0x41,0xDA,0x1E,0x54,0x08,0x09,0x78,0x0C,0x91,0xC0,0x1F,0x32,0xBC,0x9A,0x39,0x82,0xFE,0x90,0xE3,0x1A,0x00,0x3F,0xE1,0x86,0xA6,0x11,0xCE,0x5F,0xC8,0xBA,0xB1,0xDE,0xFD,0xCD,0x0C,0xF6,0x30,0x82,0x02,0x13,0x30,0x82,0x01,0xB6,0xA0,0x03,0x02,0x01,0x02,0x02,0x08,0x64,0x57,0x80,0xC4,0x70,0xA0,0xE1,0x16,0x30,0x0C,0x06,0x08,0x2A,0x81,0x1C,0xCF,0x55,0x01,0x83,0x75,0x05,0x00,0x30,0x56,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x0C,0x02,0x43,0x4E,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x08,0x0C,0x02,0x4A,0x53,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x07,0x0C,0x02,0x57,0x58,0x31,0x0D,0x30,0x0B,0x06,0x03,0x55,0x04,0x0A,0x0C,0x04,0x54,0x4D,0x52,0x49,0x31,0x0D,0x30,0x0B,0x06,0x03,0x55,0x04,0x0B,0x0C,0x04,0x54,0x4D,0x52,0x49,0x31,0x0F,0x30,0x0D,0x06,0x03,0x55,0x04,0x03,0x0C,0x06,0x52,0x46,0x49,0x44,0x43,0x41,0x30,0x1E,0x17,0x0D,0x31,0x36,0x30,0x34,0x30,0x31,0x31,0x34,0x31,0x38,0x35,0x35,0x5A,0x17,0x0D,0x33,0x36,0x30,0x34,0x30,0x31,0x31,0x34,0x31,0x38,0x35,0x35,0x5A,0x30,0x65,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x06,0x0C,0x02,0x43,0x4E,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x08,0x0C,0x02,0x4A,0x53,0x31,0x0B,0x30,0x09,0x06,0x03,0x55,0x04,0x07,0x0C,0x02,0x57,0x58,0x31,0x0D,0x30,0x0B,0x06,0x03,0x55,0x04,0x0A,0x0C,0x04,0x54,0x4D,0x52,0x49,0x31,0x0D,0x30,0x0B,0x06,0x03,0x55,0x04,0x0B,0x0C,0x04,0x54,0x4D,0x52,0x49,0x31,0x1E,0x30,0x1C,0x06,0x03,0x55,0x04,0x03,0x0C,0x15,0x31,0x52,0x52,0x41,0x30,0x31,0x30,0x30,0x32,0x30,0x30,0x30,0x38,0x37,0x52,0x46,0x49,0x44,0x53,0x41,0x4D,0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,0x06,0x08,0x2A,0x81,0x1C,0xCF,0x55,0x01,0x82,0x2D,0x03,0x42,0x00,0x04,0xD2,0x00,0x32,0xA4,0x5E,0xD4,0xA3,0xB5,0xE3,0xB6,0x05,0x88,0x03,0x00,0x3A,0x7C,0x1A,0x68,0xF0,0x97,0xD2,0x9E,0x7A,0x81,0x3F,0x88,0xCD,0x4F,0xDB,0x04,0x1C,0x5D,0xE5,0xF5,0xBB,0x31,0xA4,0x81,0xE1,0xBC,0xC6,0x46,0x44,0xDA,0x50,0xA1,0xE7,0x69,0xD2,0xFE,0x1F,0xAD,0x41,0xF8,0x05,0x02,0xEB,0x10,0x5D,0xE4,0x53,0x81,0x2E,0xF7,0xA3,0x5D,0x30,0x5B,0x30,0x1F,0x06,0x03,0x55,0x1D,0x23,0x04,0x18,0x30,0x16,0x80,0x14,0x4C,0x32,0xB1,0x97,0xD9,0x33,0x1B,0xC4,0xA6,0x05,0xC1,0xC6,0xE5,0x8B,0x62,0x5B,0xF0,0x97,0x76,0x58,0x30,0x0C,0x06,0x03,0x55,0x1D,0x13,0x04,0x05,0x30,0x03,0x01,0x01,0xFF,0x30,0x0B,0x06,0x03,0x55,0x1D,0x0F,0x04,0x04,0x03,0x02,0x01,0x06,0x30,0x1D,0x06,0x03,0x55,0x1D,0x0E,0x04,0x16,0x04,0x14,0x4C,0x32,0xB1,0x97,0xD9,0x33,0x1B,0xC4,0xA6,0x05,0xC1,0xC6,0xE5,0x8B,0x62,0x5B,0xF0,0x97,0x76,0x58,0x30,0x0C,0x06,0x08,0x2A,0x81,0x1C,0xCF,0x55,0x01,0x83,0x75,0x05,0x00,0x03,0x49,0x00,0x30,0x46,0x02,0x21,0x00,0xFD,0x00,0x43,0xFB,0x91,0xF7,0x0B,0x90,0xA8,0x34,0xD0,0x5F,0xC1,0xE0,0x97,0xC8,0xF4,0x16,0xD5,0x1F,0xCE,0x59,0x63,0x5D,0x38,0xAC,0xAC,0xD0,0xD7,0x4F,0x98,0x0B,0x02,0x21,0x00,0x96,0x3D,0xE4,0x02,0x89,0x77,0xA8,0xAC,0xF8,0x39,0x67,0x46,0x20,0xB6,0x6C,0xE8,0x49,0xE5,0x74,0x45,0x56,0xCA,0x06,0x1B,0xFB,0x87,0xC2,0xF7,0x72,0x7C,0xAB,0x0E".replaceAll("X", "x");
		String[] arr = s.split(",");
		
		byte[] b=new byte[arr.length];
		for(int i=0;i<arr.length;i++){
		b[i]=(byte)Integer.parseInt(arr[i].substring(2),16);
		}
		System.out.println(Arrays.toString(b));
		try {
			String pubkeyindex = "11";
            EriReaderWriterServiceImpl readerWriterService = new EriReaderWriterServiceImpl();
			readerWriterService.activate(EriUtil.bytesToHex(b), pubkeyindex);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}


	
}
